<!DOCTYPE html>
<html>
<head>
    <title>Sequence</title>
    <script>
        const GYRO_CDGAIN = 2;
        const TRIAL_DEADZONE = 5*(Math.PI/180); // 5 degrees rotation will start the task timer
        const MOUSE_CDGAIN = (1/10) *(Math.PI/180);
        const SPHERE_SEGMENTS=64;
        const SPHERE_RADIUS = 1;
        const THREE = require('three');        
        const {ipcRenderer} = require('electron');  

        var THREE_SCENE = new THREE.Scene();
        var THREE_SPHERE;

        class Trial{
            constructor(targetQuat, targetWidth){
                this.targetInitialAngle = targetQuat;
                this.targetWidth = targetWidth;
                
                this._startTime = -1;
                this._endTime = -1;
                this._targetCone;
                this.targetFinalAngle;
                this.targetMiss;
                this.effectiveAmplitude;
                this.movementTime;

                this._onCallbacks={
                    start: ()=>{},
                    end: ()=>{}
                };
            }
            start(){

                var coneGeom = new THREE.ConeGeometry(this.targetWidth*0.5*SPHERE_RADIUS, SPHERE_RADIUS, SPHERE_SEGMENTS,1);
                for ( var i = 0; i <coneGeom.faces.length; i ++ ) {
                    i < SPHERE_SEGMENTS?  coneGeom.faces[ i ].materialIndex=0: coneGeom.faces[ i ].materialIndex=1;
                }
                var coneEndMat = new THREE.MeshBasicMaterial( { color: 0xff0000 } );
                var coneTransparentMat = new THREE.MeshBasicMaterial( { color: 0x000000, transparent: true, opacity: 0.15 } );
                var cone = new THREE.Mesh( coneGeom, new THREE.MultiMaterial([coneTransparentMat, coneEndMat]) );
                cone.setRotationFromEuler(new THREE.Euler(-Math.PI/2,0,0, 'XYZ'));
                cone.translateY(-SPHERE_RADIUS/2);

                this._targetCone = new THREE.Object3D();
                this._targetCone.add(cone);                

                this._targetCone.name = "target";

                this._targetCone.applyQuaternion(this.targetInitialAngle);          
                THREE_SCENE.add(this._targetCone);

                this._onCallbacks['start']();
            }

            end(){
                this._endTime = Date.now();
                this.movementTime = this._endTime - this._startTime;
                this.targetFinalAngle = this._targetCone.quaternion.clone();

                THREE_SCENE.remove(this._targetCone);
                this._onCallbacks['end']();
            }
            startTimer(){
                if(this._startTime<0){
                    this._startTime = Date.now();
                }                
            }
            getCone(){
                return this._targetCone;
            }

            on(event, callback){
                this._onCallbacks[event] = callback;
            }
        }

        class Sequence{
            constructor(amplitude, width, numtargets){
                this._amplitude = amplitude;
                this._width = width;
                this._totalTrials = numtargets;

                this._currentTrial = 0;
                this._onCallbacks={
                    start: ()=>{},
                    end: ()=>{},
                    trialEnd: ()=>{}
                };
                this._trials = [];

            }
            initialize(){
                var delta_angle_Z = (2*Math.PI)/this._totalTrials;

                // var startQuat = new THREE.Quaternion();
                // startQuat.setFromAxisAngle(new THREE.Vector3(0,1,0), targetAngle)

                for(var i = 0; i< this._totalTrials; i++){
                    let quat1 = new THREE.Quaternion()
                    quat1.setFromEuler(new THREE.Euler(0, this._amplitude, 0), 'XYZ');

                    let quat2 = new THREE.Quaternion()

                    let tempAngle = (delta_angle_Z*i) + (i%2?Math.PI:0);
                    quat2.setFromEuler(new THREE.Euler(0,0, tempAngle,'XYZ'));

                    // let targetVec= new THREE.Vector3(
                    //     Math.cos(delta_angle_Z*i)*Math.sin(targetAngle), 
                    //     Math.sin(delta_angle_Z*i)*Math.sin(targetAngle),
                    //     Math.cos(targetAngle)
                    // );
                    // 
                    let targetQuat = new THREE.Quaternion();
                    targetQuat.multiplyQuaternions(quat2, quat1);

                    this._trials.push(new Trial(targetQuat, this._width))       
                }

                for(let i = 0; i< this._totalTrials-1; i++){
                    this._trials[i].on('end', ()=>{
                        this._currentTrial++;
                        this._trials[i+1].start();



                        let refVect= new THREE.Vector3(0,0,1);

                        let missVect = new THREE.Vector3(0,0,1);
                        missVect.applyQuaternion(this._trials[i].targetFinalAngle);

                        let targetVect = new THREE.Vector3(0,0,1);
                        targetVect.applyQuaternion(this._trials[i].targetInitialAngle);

                        let lenA = Math.acos(refVect.dot(targetVect));
                        let lenB = Math.acos(missVect.dot(targetVect));
                        let lenC = Math.acos(refVect.dot(missVect));

                        let dx = ((lenA*lenA) + (lenC*lenC) - (lenB*lenB))/(2*lenA);
                        let effectiveAmplitude = lenA - dx;
                        console.log(effectiveAmplitude, lenA, this._trials[i].movementTime);
                    })
                }

                this._trials[this._totalTrials-1].on('end', ()=>{
                    this.end();
                });


            }
            currentTrial(){
                return this._trials[this._currentTrial];
            }

            start(){
                this._trials[0].start();
                this._onCallbacks['start']();
            }

            end(){
                this._onCallbacks['end']();
            }

            on(event, callback){
                this._onCallbacks[event] = callback;
            }
        }

        class Block {
            constructor(sequenceData){
                this._blockData={};
                this._sequences=[];
                this._currentSequence=0;

                sequenceData ? this.blockData = sequenceData : null; 

                this._onCallbacks={
                    start: ()=>{},
                    end: ()=>{},
                    ready: ()=>{}
                };
            }

            on(event, callback){
                this._onCallbacks[event] = callback;
            }

            initialize(){
                var aspect = window.innerWidth / window.innerHeight;
                var frustum = SPHERE_RADIUS*1.1;
                
                var camera = new THREE.OrthographicCamera( -frustum * aspect, frustum * aspect, frustum, -frustum, 1, 1000 );
                // var camera = new THREE.PerspectiveCamera( 75, aspect, 0.1, 1000 );
                var renderer = new THREE.WebGLRenderer();
                renderer.setSize( window.innerWidth, window.innerHeight );
                renderer.setClearColor (0xffffff, 1);
                document.body.appendChild( renderer.domElement );

                camera.position.set(0, 0, 50);
                // camera.setRotationFromEuler(new THREE.Euler(0,0,Math.PI, 'ZYX'))

                var light = new THREE.PointLight(0xffffff);
                light.position.set(0, 0, 4);
                
                var sphereGeom = new THREE.SphereGeometry(SPHERE_RADIUS, SPHERE_SEGMENTS, SPHERE_SEGMENTS);            

                var loader = new THREE.TextureLoader().load("img/metal.jpg", (texture)=>{
                    var metalMat = new THREE.MeshBasicMaterial({map: texture, transparent: true, opacity: 0.15});
                    var metalSphere = new THREE.Mesh(sphereGeom, metalMat);
                    metalSphere.renderOrder=1;
                    metalSphere.name = "sphere";

                    THREE_SPHERE = new THREE.Group()

                    THREE_SPHERE.add(metalSphere)
                    THREE_SCENE.add( THREE_SPHERE);
                    var crossMat = new THREE.LineBasicMaterial({ color: 0x000000 });

                    // crosshair size
                    var x = 0.03, y = 0.03;

                    var crossGeom = new THREE.Geometry();

                    // crosshair
                    crossGeom.vertices.push(new THREE.Vector3(0, y, 0));
                    crossGeom.vertices.push(new THREE.Vector3(0, -y, 0));
                    crossGeom.vertices.push(new THREE.Vector3(0, 0, 0));
                    crossGeom.vertices.push(new THREE.Vector3(x, 0, 0));    
                    crossGeom.vertices.push(new THREE.Vector3(-x, 0, 0));

                    var crosshair = new THREE.Line( crossGeom, crossMat );

                    crosshair.position.x = 0;
                    crosshair.position.y = 0;

                    crosshair.position.z = 1.1;


                    THREE_SCENE.add( crosshair );

                    
                    var render = function () {
                      requestAnimationFrame( render );
                      renderer.render( THREE_SCENE, camera );
                    };
                    render();

                    this._updateInputMethods();
                    this._createSequences();
                    this._onCallbacks['ready']();
                });
            }
            _updateInputMethods(){
                if(this._blockData['inputType']==='mouse'){
                    document.body.requestPointerLock = document.body.requestPointerLock ;
                    // Ask the browser to lock the pointer
                    document.body.requestPointerLock();
                    document.addEventListener('mousemove', (event)=>{
                        var deltaX= event.movementX;
                        var deltaY= event.movementY;

                        this._deltaSphereEuler(deltaY*MOUSE_CDGAIN,deltaX*MOUSE_CDGAIN,0,'XYZ');

                    }, false);
                } 
                else if(this._blockData['inputType']==='gyroscope'){
                    ipcRenderer.on('device:rotation', (event, rot)=>{
                        this._setSphereEuler(rot.beta, rot.alpha, -rot.gamma, 'YXZ');
                    })
                }
                document.body.addEventListener("keypress", (event)=>{
                    if(event.code==="Enter"){
                        this.currentTrial().end();
                    } 
                });
            }
            _deltaSphereEuler(x, y, z, order){
                var deltaRotationQuaternion = new THREE.Quaternion()
                    .setFromEuler(new THREE.Euler(
                        x,
                        y,
                        z,
                        order
                    ));
                var curCone = this.currentTrial().getCone()
                if(curCone){
                    curCone.quaternion.multiplyQuaternions(deltaRotationQuaternion, curCone.quaternion);
                    let refVect= new THREE.Vector3(0,0,1);
                    refVect.applyQuaternion(this.currentTrial().targetInitialAngle);
                    let coneVect = new THREE.Vector3(0,0,1);
                    coneVect.applyQuaternion(curCone.quaternion);
                    if(Math.acos(refVect.dot(coneVect))>TRIAL_DEADZONE){
                        this.currentTrial().startTimer()
                    }
                }            
                THREE_SPHERE.quaternion.multiplyQuaternions(deltaRotationQuaternion, THREE_SPHERE.quaternion);

            }
            _setSphereEuler(x, y, z, order){
                var deltaRotationQuaternion = new THREE.Quaternion()
                    .setFromEuler(new THREE.Euler(
                        x,
                        y,
                        z,
                        order
                    ));
                var curCone = this.currentTrial().getCone() 
                if(curCone){
                    curCone.quaternion.multiplyQuaternions(deltaRotationQuaternion, new THREE.Quaternion(0,0,0,1));
                    let refVect= new THREE.Vector3(0,0,1);
                    refVect.applyQuaternion(this.currentTrial().targetInitialAngle);
                    let coneVect = new THREE.Vector3(0,0,1);
                    coneVect.applyQuaternion(curCone.quaternion);
                    if(Math.acos(refVect.dot(coneVect))>TRIAL_DEADZONE){
                        this.currentTrial().startTimer()
                    }
                }   
                THREE_SPHERE.quaternion.multiplyQuaternions(deltaRotationQuaternion, new THREE.Quaternion(0,0,0,1));
            }

            _createSequences(){
                for(let i = 0; i < this._blockData['sequences'].length; i++){
                    let seq = this._blockData['sequences'][i];
                    var newSequence = new Sequence(seq.amplitude, seq.width, this._blockData['trials']);
                    newSequence.on('end', ()=>{
                        //show sequence summary
                        console.log('sequence done');
                        this._currentSequence++;
                        this.currentSequence().start();
                    })
                    newSequence.initialize();
                    this._sequences.push(newSequence);
                }                
            }

            currentSequence(){
                return this._sequences[this._currentSequence];
            }
            currentTrial(){
                return this.currentSequence().currentTrial();
            }

            set blockData(data){
                this._blockData = data;
                console.log(this._blockData)
            }            
        }

    </script>    
</head>
<body style="overflow:hidden; margin: 0 0 0 0;">

<!--     <script type="text/javascript" src="js/lib/three.min.js"></script>  -->

    <script type="text/javascript">



        var experiment;


        ipcRenderer.on('sequence:start', (event, sequenceData)=>{
            experiment = new Block(sequenceData);
            experiment.initialize();
            experiment.on('ready', ()=>{
                experiment.currentSequence().start();
            })
         })




    </script>
</body>
</html>