<!DOCTYPE html>
<html>
<head>
    <title>Sequence</title>
    <script>
        const SD1_HEADERS = ['Participant', 'Condition', 'Block', 'Trial', 'A', 'W', 'Ae', 'dx', 'MT', 'Error'];
        const SD2_HEADERS = ['Participant', 'Condition', 'Block', 'SRC', 'Trials', 'A', 'W', 'ID', 'Ae', 'We', 'IDe', 'MT', 'ER', 'TP']
        const TRIAL_DEADZONE = 5*(Math.PI/180); // 5 degrees rotation will start the task timer
        const MOUSE_CDGAIN = (1/10) *(Math.PI/180);
        const JOYSTICK_CDGAIN = (2.5) *(Math.PI/180);
        const JOYSTICK_DEADZONE = 0.15;
        const SPHERE_SEGMENTS=64;
        const SPHERE_RADIUS = 1;
        const INPUT_LOGGING = true;
        const THREE = require('three');        
        const {ipcRenderer} = require('electron');  

        var THREE_SCENE = new THREE.Scene();
        var THREE_SPHERE;

        class Trial{
            constructor(trialI, targetQuat, targetWidth){
                this.targetInitialAngle = targetQuat;
                this.W = targetWidth;
                this.A;
                this.Trial = trialI;
                
                this._startTime = -1;
                this._endTime = -1;
                this._targetCone;
                this.targetFinalAngle;
                this.dx;
                this.Ae;
                this.MT;
                this.Error;

                this._onCallbacks={
                    start: [],
                    end: []
                };
            }
            start(){

                var coneGeom = new THREE.ConeGeometry(this.W*0.5*SPHERE_RADIUS, SPHERE_RADIUS, SPHERE_SEGMENTS,1);
                for ( var i = 0; i <coneGeom.faces.length; i ++ ) {
                    i < SPHERE_SEGMENTS?  coneGeom.faces[ i ].materialIndex=0: coneGeom.faces[ i ].materialIndex=1;
                }
                var coneEndMat = new THREE.MeshBasicMaterial( { color: 0xff0000 } );
                var coneTransparentMat = new THREE.MeshBasicMaterial( { color: 0x000000, transparent: true, opacity: 0.15 } );
                var cone = new THREE.Mesh( coneGeom, new THREE.MultiMaterial([coneTransparentMat, coneEndMat]) );
                cone.setRotationFromEuler(new THREE.Euler(-Math.PI/2,0,0, 'XYZ'));
                cone.translateY(-SPHERE_RADIUS/2);

                this._targetCone = new THREE.Object3D();
                this._targetCone.add(cone);                

                this._targetCone.name = "target";

                this._targetCone.applyQuaternion(this.targetInitialAngle);          
                THREE_SCENE.add(this._targetCone);


                this._onCallbacks['start'].forEach((fn)=>{fn()});
            }

            end(){
                this.startTimer(); //so that time cant be negative
                this._endTime = Date.now();
                this.MT = this._endTime - this._startTime;
                this.targetFinalAngle = this._targetCone.quaternion.clone();

                let refVect= new THREE.Vector3(0,0,1);

                let missVect = new THREE.Vector3(0,0,1);
                missVect.applyQuaternion(this.targetFinalAngle);

                let targetVect = new THREE.Vector3(0,0,1);
                targetVect.applyQuaternion(this.targetInitialAngle);

                let lenA = Math.acos( Math.max(Math.min(1, refVect.dot(targetVect)), -1) );
                let lenB = Math.acos( Math.max(Math.min(1, missVect.dot(targetVect)), -1) );
                let lenC = Math.acos( Math.max(Math.min(1, refVect.dot(missVect)), -1) );

                this.Error = +(lenC > (this.W/2));
                this.dx = ((lenA*lenA) + (lenC*lenC) - (lenB*lenB))/(2*lenA);
                this.A = lenA.toFixed(6);
                this.Ae = lenA - this.dx;

                let toSend = JSON.parse(
                    JSON.stringify(this, SD1_HEADERS)                
                )
                ipcRenderer.send('trial:end', toSend);

                THREE_SCENE.remove(this._targetCone);
                this._onCallbacks['end'].forEach((fn)=>{fn()});
            }
            startTimer(){
                if(this._startTime<0){
                    this._startTime = Date.now();
                }                
            }
            getCone(){
                return this._targetCone;
            }

            on(event, callback){
                this._onCallbacks[event].push(callback);
            }
        }

        class Sequence{
            constructor(amplitude, width, numtargets){
                this.A = amplitude;
                this.W = width;
                this.Trials = numtargets;
                this.ID = Math.log2((this.A/this.W) + 1);
                this.SRC=0;

                this.Ae;
                this.We;
                this.IDe;
                this.MT;
                this.ER;
                this.TP;

                
                this._onCallbacks={
                    start: [],
                    end: []
                };               

            }
            initialize(){
                this._currentTrial = 0;
                this._trials = [];
                var delta_angle_Z = (Math.PI)/this.Trials;

                // var startQuat = new THREE.Quaternion();
                // startQuat.setFromAxisAngle(new THREE.Vector3(0,1,0), targetAngle)

                for(var i = 0; i< this.Trials; i++){
                    let quat1 = new THREE.Quaternion()
                    quat1.setFromEuler(new THREE.Euler(0, this.A, 0), 'XYZ');

                    let quat2 = new THREE.Quaternion()

                    let tempAngle = (delta_angle_Z*i) + (i%2?Math.PI:0);
                    quat2.setFromEuler(new THREE.Euler(0,0, tempAngle,'XYZ'));

                    // let targetVec= new THREE.Vector3(
                    //     Math.cos(delta_angle_Z*i)*Math.sin(targetAngle), 
                    //     Math.sin(delta_angle_Z*i)*Math.sin(targetAngle),
                    //     Math.cos(targetAngle)
                    // );
                    // 
                    let targetQuat = new THREE.Quaternion();
                    targetQuat.multiplyQuaternions(quat2, quat1);

                    this._trials.push(new Trial(i, targetQuat, this.W))       
                }

                for(let i = 0; i< this.Trials-1; i++){
                    this._trials[i].on('end', ()=>{
                        this._currentTrial++;
                        this._trials[i+1].start();
                    })
                }

                this._trials[this.Trials-1].on('end', ()=>{
                    this.end();
                });


            }
            currentTrial(){
                return this._trials[this._currentTrial];
            }

            start(){
                this._trials[0].start();
                this._onCallbacks['start'].forEach((fn)=>{fn()});
            }

            end(){
                this.ER = 100*this._trials.reduce( (acc,trial) => acc+trial.Error, 0 ) / this._trials.length;
                this.MT = this._trials.reduce( (acc,trial) => acc+trial.MT, 0 ) / this._trials.length;
                this.Ae = this._trials.reduce( (acc,trial) => acc+trial.Ae, 0 ) / this._trials.length;
                this.We = 4.133*standardDeviation(this._trials.map( (trial)=> trial.dx));
                this.IDe = Math.log2((this.Ae/this.We) + 1);
                this.TP = (this.IDe/this.MT)*1000;


                let toSend = JSON.parse(
                    JSON.stringify(this, SD2_HEADERS)                
                )
                ipcRenderer.send('sequence:end', toSend);

                this._onCallbacks['end'].forEach((fn)=>{fn()});
            }

            on(event, callback){
                this._onCallbacks[event].push(callback);
            }
        }

        class Block {
            constructor(sequenceData){
                this._blockData={};
                this._sequences=[];
                this.sequenceIndex=0;

                this._gamePad;

                sequenceData ? this.blockData = sequenceData : null; 

                this._onCallbacks={
                    start: [],
                    end: [],
                    ready: [],
                    input:[]
                };
            }

            on(event, callback){
                this._onCallbacks[event].push(callback);
            }

            initialize(){
                var aspect = window.innerWidth / window.innerHeight;
                var frustum = SPHERE_RADIUS*1.1;
                
                var camera = new THREE.OrthographicCamera( -frustum * aspect, frustum * aspect, frustum, -frustum, 1, 1000 );
                // var camera = new THREE.PerspectiveCamera( 75, aspect, 0.1, 1000 );
                var renderer = new THREE.WebGLRenderer();
                renderer.setSize( window.innerWidth, window.innerHeight );
                renderer.setClearColor (0xffffff, 1);
                document.body.appendChild( renderer.domElement );

                camera.position.set(0, 0, 50);
                // camera.setRotationFromEuler(new THREE.Euler(0,0,Math.PI, 'ZYX'))

                var light = new THREE.PointLight(0xffffff);
                light.position.set(0, 0, 4);
                
                var sphereGeom = new THREE.SphereGeometry(SPHERE_RADIUS, SPHERE_SEGMENTS, SPHERE_SEGMENTS);            

                var loader = new THREE.TextureLoader().load("img/metal.jpg", (texture)=>{
                    var metalMat = new THREE.MeshBasicMaterial({map: texture, transparent: true, opacity: 0.15});
                    var metalSphere = new THREE.Mesh(sphereGeom, metalMat);
                    metalSphere.renderOrder=1;
                    metalSphere.name = "sphere";

                    THREE_SPHERE = new THREE.Group()

                    THREE_SPHERE.add(metalSphere)
                    THREE_SCENE.add( THREE_SPHERE);
                    var crossMat = new THREE.LineBasicMaterial({ color: 0x000000 });

                    // crosshair size
                    var x = 0.03, y = 0.03;

                    var crossGeom = new THREE.Geometry();

                    // crosshair
                    crossGeom.vertices.push(new THREE.Vector3(0, y, 0));
                    crossGeom.vertices.push(new THREE.Vector3(0, -y, 0));
                    crossGeom.vertices.push(new THREE.Vector3(0, 0, 0));
                    crossGeom.vertices.push(new THREE.Vector3(x, 0, 0));    
                    crossGeom.vertices.push(new THREE.Vector3(-x, 0, 0));

                    var crosshair = new THREE.Line( crossGeom, crossMat );

                    crosshair.position.x = 0;
                    crosshair.position.y = 0;

                    crosshair.position.z = 1.1;


                    THREE_SCENE.add( crosshair );

                    
                    var render = function () {
                      requestAnimationFrame( render );
                      renderer.render( THREE_SCENE, camera );
                    };
                    render();

                    this._updateInputMethods();
                    this._createSequences();
                    if(INPUT_LOGGING){
                        const log_time = 1000;
                        let angle_sum = 0;
                        setInterval(()=>{
                            console.log(`Angle per ${log_time} ms: ${angle_sum*180/Math.PI} degrees`);
                            angle_sum = 0;

                        }, log_time)

                        this.on('input', (angleDiff)=>{
                            angle_sum+=angleDiff;
                        })

                    }
                    this._onCallbacks['ready'].forEach((fn)=>{fn()});
                });
            }
            _updateInputMethods(){
                if(this._blockData['inputType']==='mouse'){
                    document.body.requestPointerLock = document.body.requestPointerLock ;
                    // Ask the browser to lock the pointer
                    document.body.requestPointerLock();
                    document.addEventListener('mousemove', (event)=>{
                        var deltaX= event.movementX;
                        var deltaY= event.movementY;

                        this._deltaSphereEuler(deltaY*MOUSE_CDGAIN,deltaX*MOUSE_CDGAIN,0,'XYZ');

                    }, false);
                } 
                else if(this._blockData['inputType']==='gyroscope'){
                    ipcRenderer.on('device:rotation', (event, rot)=>{
                        this._setSphereEuler(rot.beta, rot.alpha, -rot.gamma, 'YXZ');
                    })
                }
                else if(this._blockData['inputType']==='joystick'){
                    window.addEventListener("gamepadconnected", (e)=> {                        
                        var updateGamepad =  ()=> {
                            requestAnimationFrame( updateGamepad );

                            var gp = navigator.getGamepads()[e.gamepad.index];                        
                            if(gp.id.indexOf('Xbox 360 Controller')>=0){
                                let xSqr = gp.axes[3]*gp.axes[3];
                                let ySqr = gp.axes[2]*gp.axes[2];
                                let magnitude = Math.sqrt( xSqr+ySqr  ); 

                                if(magnitude>= JOYSTICK_DEADZONE){
                                    this._deltaSphereEuler(gp.axes[3]*magnitude*JOYSTICK_CDGAIN,gp.axes[2]*magnitude*JOYSTICK_CDGAIN,0,'XYZ');
                                }                                
                            }
                        };
                        updateGamepad();                        
                    });

                }
                document.body.addEventListener("keypress", (event)=>{
                    if(event.code==="Enter"){
                        this.currentTrial().end();
                    } 
                });
            }
            _deltaSphereEuler(x, y, z, order){
                var deltaRotationQuaternion = new THREE.Quaternion()
                    .setFromEuler(new THREE.Euler(
                        x,
                        y,
                        z,
                        order
                    ));
                var curCone = this.currentTrial().getCone()
                if(curCone){
                    let prevConeVect =  new THREE.Vector3(0,0,1);
                    prevConeVect.applyQuaternion(curCone.quaternion);

                    curCone.quaternion.multiplyQuaternions(deltaRotationQuaternion, curCone.quaternion);
                    let refVect= new THREE.Vector3(0,0,1);
                    refVect.applyQuaternion(this.currentTrial().targetInitialAngle);
                    let coneVect = new THREE.Vector3(0,0,1);
                    coneVect.applyQuaternion(curCone.quaternion);

                    this._onCallbacks['input'].forEach((fn)=>{fn(Math.acos(prevConeVect.dot(coneVect)))}); 
                    if(Math.acos(refVect.dot(coneVect))>TRIAL_DEADZONE){
                        this.currentTrial().startTimer()
                    }
                    
                }
                           
                THREE_SPHERE.quaternion.multiplyQuaternions(deltaRotationQuaternion, THREE_SPHERE.quaternion);

            }
            _setSphereEuler(x, y, z, order){
                var deltaRotationQuaternion = new THREE.Quaternion()
                    .setFromEuler(new THREE.Euler(
                        x,
                        y,
                        z,
                        order
                    ));
                var curTrial = this.currentTrial();
                var curCone = curTrial.getCone() 
                if(curCone){
                    let prevConeVect =  new THREE.Vector3(0,0,1);
                    prevConeVect.applyQuaternion(curCone.quaternion);

                    curCone.quaternion.multiplyQuaternions(deltaRotationQuaternion, curTrial.targetInitialAngle);
                    let refVect= new THREE.Vector3(0,0,1);
                    refVect.applyQuaternion(this.currentTrial().targetInitialAngle);
                    let coneVect = new THREE.Vector3(0,0,1);
                    coneVect.applyQuaternion(curCone.quaternion);
                    if(Math.acos(refVect.dot(coneVect))>TRIAL_DEADZONE){
                        this.currentTrial().startTimer()
                    }
                    this._onCallbacks['input'].forEach((fn)=>{fn(Math.acos(prevConeVect.dot(coneVect)))}); 
                }                    
                THREE_SPHERE.quaternion.multiplyQuaternions(deltaRotationQuaternion, curTrial.targetInitialAngle);
            }


            _createSequences(){
                for(let i = 0; i < this._blockData['sequences'].length; i++){
                    let seq = this._blockData['sequences'][i];
                    var newSequence = new Sequence(seq.amplitude, seq.width, this._blockData['trials']);
                    newSequence.on('end', ()=>{
                        //show sequence summary
                    })
                    newSequence.initialize();
                    this._sequences.push(newSequence);
                }                
            }
            nextSequence(){

                this.sequenceIndex++;
                if(this.sequenceIndex<this._sequences.length){
                    this.currentSequence().start();
                }
                else{
                    //finished all sequences
                    this._onCallbacks['end'].forEach((fn)=>{fn()});
                }
                
            }
            repeatCurrentSequence(){
                this.currentSequence().SRC++;
                this.currentSequence().initialize();
                this.currentSequence().start();
            }
            currentSequence(){
                return this._sequences[this.sequenceIndex];
            }
            currentTrial(){
                return this.currentSequence().currentTrial();
            }


            set blockData(data){
                this._blockData = data;
                console.log(this._blockData)
            }            
        }

        function standardDeviation(values){
          var avg = average(values);
          
          var squareDiffs = values.map(function(value){
            var diff = value - avg;
            var sqrDiff = diff * diff;
            return sqrDiff;
          });
          
          var avgSquareDiff = average(squareDiffs);

          var stdDev = Math.sqrt(avgSquareDiff);
          return stdDev;
        }

        function average(data){
          var sum = data.reduce(function(sum, value){
            return sum + value;
          }, 0);

          var avg = sum / data.length;
          return avg;
        }

    </script>    
</head>
<body style="overflow:hidden; margin: 0 0 0 0;">

<!--     <script type="text/javascript" src="js/lib/three.min.js"></script>  -->

    <script type="text/javascript">



        var experiment;


        ipcRenderer.on('block:start', (event, sequenceData)=>{
            experiment = new Block(sequenceData);
            experiment.initialize();
            experiment.on('ready', ()=>{
                experiment.currentSequence().start();
            })

            experiment.on('end', ()=>{
                ipcRenderer.send('block:end', {});
            })

            ipcRenderer.on('sequence:next', (event, sequenceData)=>{
                experiment.nextSequence();
            })
            ipcRenderer.on('sequence:tooManyErrors', (event, sequenceData)=>{
                experiment.repeatCurrentSequence();
            })
        })






    </script>
</body>
</html>